<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Expert C Programming</title>
<!-- 2018-03-18 Sun 21:22 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="dqy" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../org/css/org0.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Expert C Programming</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. C: 穿越时空的迷雾</a>
<ul>
<li><a href="#sec-1-1">1.1. 限定符</a></li>
<li><a href="#sec-1-2">1.2. 联合</a></li>
</ul>
</li>
<li><a href="#sec-2">2. 这不是Bug，而是语言特性</a></li>
<li><a href="#sec-3">3. 分析C语言的声明</a></li>
<li><a href="#sec-4">4. 令人震惊的事实：数组和指针并不相同</a></li>
<li><a href="#sec-5">5. 对链接的思考</a>
<ul>
<li><a href="#sec-5-1">5.1. 编译器</a></li>
<li><a href="#sec-5-2">5.2. 动态与静态链接</a></li>
<li><a href="#sec-5-3">5.3. 函数库链接的秘密</a></li>
<li><a href="#sec-5-4">5.4. 警惕Interpositoning</a></li>
</ul>
</li>
<li><a href="#sec-6">6. 运动的诗章：运行时数据结构</a></li>
<li><a href="#sec-7">7. 对内存的思考</a></li>
<li><a href="#sec-8">8. 为什么程序员无法分清万圣节和圣诞节</a></li>
<li><a href="#sec-9">9. 再论数组</a></li>
<li><a href="#sec-10">10. 再论指针</a></li>
<li><a href="#sec-11">11. 你懂得C，所以C++不在话下</a></li>
<li><a href="#sec-12">12. 附录 程序员工作面试的秘密</a></li>
</ul>
</div>
</div>
<p>
C语言的设计哲学:<br  />
一切工作程序员自己负责。<br  />
语言中的所有特性都不需要隐式的运行时支持。<br  />
程序员所做的都是对的。<br  />
程序员应该知道自己在干什么，并保证自己的所作所为是正确的。<br  />
</p>

<p>
c诡异离奇，缺陷重重，却获得了巨大的成功<br  />
</p>

<p>
const和*的组合通常只用于在数组形式的参数中模拟传值调用。他声称“我给你一个指向他的指针，但你不能修改它”，这个约定类似于极为常见的void*用法，尽管在理论上他可以用于任何情形，但通常被限制于把指针从一种类型装换到另一种类型。<br  />
const int limit = 10;<br  />
const int *lp = &amp;limit;<br  />
lp是一个指向常量整型的指针。这个指针不能用于修改这个整形数，但在任何时候，这个指针本身的值却可以改变。这样，它指向了不同的地址，对它进行解除引用操作会得到一个不同的值。<br  />
</p>

<p>
安静的改变<br  />
1.算数转换 2。字符和整型（整形升级）3.寻常算数转换<br  />
（无符号保留原则）当一个无符号类型与int或更小的整型混合使用时，结果类型是无符号类型。 对应的就是（值保留原则（可能是有符号数，可能是无符号数，取决于操作数的类型的相对的大小））<br  />
尽量不用无符号数！！！<br  />
sizeof返回unsigned int<br  />
只有在使用位段和二进制掩码时，才可以使用无符号数。可以使用强制类型转换<br  />
一个L的NUL用于结束一个ASCII码零的正确术语。<br  />
两个L的NULL用于表示什么也不指向（空指针）。<br  />
</p>

<p>
i = 1, 2;<br  />
因为=运算符高于,，所以（i=1）后，i被赋值为1, 2这个运算无意义，最终i = 1<br  />
</p>

<p>
函数中，不能把局部变量的指针，作为返回值。<br  />
</p>
<pre class="example">
解决办法：
@返回一个指向字符串常量的指针（只适用于简单的字符串）
char* func(){reutrn "wahaha!";}
@使用全局声明的数组
@使用静态数组（和全局数组一样，大型缓冲区若果闲置不用，非常浪费内存空间）
@显式分配一些内存，保存返回的值
char * func(){
char *s = malloc(20);
return s;
}
它应用于多线程的代码。缺点在于程序员必须承担内存管理的责任
@最好由调用者分配内存来保存函数的返回值。
void func(char* result, int size){
}
</pre>



<p>
数组定义申明：<br  />
</p>
<div class="org-src-container">

<pre class="src src-C">my_array[100]; //分配了内存
extern int my_array[];  //描述其他地方创建的数据
</pre>
</div>

<p>
动态函数库链接，-lthread &#x2013;&gt; libthread.so 应该放于右侧。 gcc a.c -lthread<br  />
要小心定义的函数名与函数库里面存在相同的函数名。<br  />
size命令会查看段大小，文本段，数据段，bss段； size a.out<br  />
calloc是分配清0后的内存块。<br  />
总线错误：几乎都是由于未对齐的读/写引起的。<br  />
有限状态机：它的基本思路是用一张表保存所有可能的状态，并列出进入每个状态时可能执行的所有动作，其中最后一个动作就是计算下一个应该进入的状态。<br  />
数组与指针可互换使用的时机：形参时、表达式内计算时<br  />
不是互换：声明时、定义时<br  />
</p>
<pre class="example">
pae[2][3]---&gt;  pae[0] 他既是元素，也是一个数组的首地址。pae[0]---&gt;[0][1][2]
</pre>


<p>
1.函数库调用/系统调用 区别：<br  />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">库函数调用</th>
<th scope="col" class="left">系统调用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">标准C中，C函数库是相同的</td>
<td class="left">各OS的系统调用是不同的</td>
</tr>

<tr>
<td class="left">调库中一个程序</td>
<td class="left">调系统内核的服务</td>
</tr>

<tr>
<td class="left">与用户程序相联系</td>
<td class="left">是操作系统的一个进入点</td>
</tr>

<tr>
<td class="left">在用户地址空间执行</td>
<td class="left">在内核地址空间执行</td>
</tr>

<tr>
<td class="left">属于用户运行时间</td>
<td class="left">属于系统运行时间</td>
</tr>

<tr>
<td class="left">过程调用，开销小。</td>
<td class="left">需在用户态与系统内核态切换上下文，开销大</td>
</tr>

<tr>
<td class="left">libc中越300个程序</td>
<td class="left">unix中约90个系统调用</td>
</tr>
</tbody>
</table>
<p>
性能考虑上，应尽量减少系统调用。<br  />
</p>

<p>
如何确定一个变量是有符合还是无符号？<br  />
无符号的本质是永远不会为负号，有符号的则对最左边一个位取补将全改变它的符号。<br  />
#define ISUNISIGNED(a) (a&gt;=0 &amp;&amp; ~a&gt;=0)<br  />
#define ISUNISIGNED(type)  ((type)0-1 &gt; 0)<br  />
</p>


<p>
definition 和 declaration区别：<br  />
definition 只能出现一次<br  />
declaration 能出现很多次<br  />
</p>

<p>
文件描述符，文件指针区别：<br  />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">文件描述符</td>
<td class="left">文件指针</td>
</tr>

<tr>
<td class="left">他是一个小整数用于存放开放文件的每个进程表</td>
<td class="left">是一个流结构，它包含流缓冲区，文件数据的变量，buff字节大小流状态</td>
</tr>

<tr>
<td class="left">使用它将，程序失去可移植性</td>
<td class="left">标准的I/O制定，文件指针。具备不同系统的可移植性</td>
</tr>

<tr>
<td class="left">是文件的每个进程表的偏移量，用于unix系统调用，标识文件</td>
<td class="left">是FILE结构地址，表示开放的I/O流，用于C库I/O库调用，用于标识文件</td>
</tr>

<tr>
<td class="left">create() open() read()</td>
<td class="left">fopen()  fwrite()  fread()</td>
</tr>
</tbody>
</table>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> C: 穿越时空的迷雾</h2>
<div class="outline-text-2" id="text-1">
<p>
小即是美。事物发展都有个过程，由简入繁，不能一开始就想得太复杂，Multics，IBM的OS/360都是因此而失败。<br  />
C语言的许多特性是为了方便编译器设计者而建立的<br  />
C语言的基本数据类型直接与底层硬件相对应<br  />
register关键字，这个设计可以说是一个失误，如果让编译器在使用各个变量时自动处理寄存器的分配工作，显然比一经声明就把这类变量在生命周期内始终保留在寄存器里要好，使用register关键字，简化了编译器，却把包袱丢给了程序员。<br  />
C编译器不曾实现的一些功能必须通过其他途径实现&#x2014;标准I/O库和C预处理器。<br  />
</p>

<p>
在宏扩展中，空格会对扩展的结果造成很大的影响。<br  />
宏后面不可加';'，它不是C语句。<br  />
宏最好只用于命名常量，并为一些适当的结构提供简捷的记法。宏名应该大写这样便很容易与函数调用区分开来。<br  />
</p>

<p>
const关键字原先如果命名为readonly就好多了。<br  />
</p>
<pre class="example">
const int *p;是指不能够通过通过p来改变int的值，即：*p = 30和p[3] = 4都是错误，但p是可以改变。
const int *与int *是相容的，都是指向int的指针；const int **与int **不相容，前者是指向const int *的指针，int **是指向int *的指针。
</pre>

<p>
尽量不要在你的代码中使用无符号类型，以免增加不必要的复杂性。只有在使用位段和二进制掩码时，才可以使用无符号数。应该在表达式中使用强制类型转换，使操作数均为有符号数，或者无符号数，这样就不必由编译器来选择结果的类型。<br  />
有个例子，在ANSI C中，-1 &lt; (unsigned char)1 为真，而-1 &lt; (unsigned int)1 为假。<br  />
</p>


<p>
全局变量和静态变量的区别<br  />
从四方面：一为修饰符，二为存储地址，三为生命周期，四为外部可访问性。<br  />
修饰符：全局变量在源文件的函数外部声明(不含extern)，但若其它源文件要调用这个变量，就需要通过extern关键字来引用一下。静态变量用static来修饰；<br  />
存储地址：两者都是存储在静态存储区，非堆栈上，它们与局部变量的存储分开； 关于内存分配，参看网站<a href="http://www.cppblog.com/elva/archive/2009/10/30/99811.html">http://www.cppblog.com/elva/archive/2009/10/30/99811.html</a><br  />
生命周期：两者都是在程序编译时或程序装入时由系统自动分配的，程序结束时消亡；<br  />
外部可访问性：全局变量在整个程序的任何地方均可访问，而静态变量相当于面向对象中的私有变量，它的可访问性只限定于声明它的那个源文件，即作用域仅局限于本文件(静态函数也一样)；<br  />
</p>

<p>
K&amp;R C和ANSI C两种不同C中，类型转换的保留原则<br  />
K&amp;R C：无符号保留，当无符号变量与其他有符号变量运算，结果保留无符号<br  />
ANSI C：有符号保留<br  />
</p>

<p>
NUL：结束一个ASCII字符串<br  />
NULL：什么也不指向(空指针)<br  />
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 限定符</h3>
<div class="outline-text-3" id="text-1-1">
<p>
C语言规定，合法的指针赋值两个操作数都是指向有限定符或无限定符的相容类型的指针。<br  />
左边指针所指向的类型必须是右边指针所指向类型的全部限定符<br  />
char *cp;<br  />
const char *ccp;<br  />
ccp = cp;<br  />
左操作数是一个指向有const限定符的char的指针，右操作数是指向没有限定符的char的指针。<br  />
char与char相容，左边包含右边，所以赋值合法。但是反过来就会有编译警告<br  />
"error C2440: '=' : cannot convert from 'const char *' to 'char *'"<br  />
</p>


<p>
const<br  />
const声明的变量只读，表示constant，就是常量<br  />
const 最有用之处就是用他来限定函数的形参，这样该函数将不会修改实参指针所指的数据<br  />
</p>

<p>
sizeof(arr[ 0]) 的写法比sizeof(int)更具有很好的移植性。因为我们可以改数据类型而不用改该表达式<br  />
</p>

<p>
标准C编译器至少允许switch满足257个case,即满足一个“字符“的所有情况。1个8bit位的所有情况<br  />
</p>

<p>
"a"<br  />
"b"<br  />
"c",如果漏掉，号，则上下行字符串会自动相连。"abc"<br  />
</p>

<p>
加上static,可限制函数的可见性，缺省是全局可见的<br  />
</p>


<p>
int(*func()) () ; 返回一个函数指针<br  />
int (*func())[]; 返回一个指向数组的指针<br  />
尽量让一行代码只做一件事情，别复杂了<br  />
</p>
</div>
</div>


<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 联合</h3>
<div class="outline-text-3" id="text-1-2">
<p>
联合与结构最大的区别是后者每个成员依次存储，而联合每个成员都从偏移地址零开始存储，每个成员的位置重叠在一起，某个时刻只有一个成员真正被使用<br  />
</p>
<div class="org-src-container">

<pre class="src src-C">union bits32_tag  
{  
    int whole;  
    struct {char c0, c1, c2, c3;} byte;  
}value;
</pre>
</div>
<p>
使用时可以提取一个32位的整数，也可以提取某个字节<br  />
</p>

<p>
指针的初始化<br  />
定义指针时，并不分配空间,只是分配指针本身的空间。除非在定义时用字符串常量初始化<br  />
char *p = "breadfruit";<br  />
只有字符串常量才可以这样初始化，其它不行，比如，<br  />
float *pip = 3.14; //error<br  />
注意，指针字符串常量是不可以修改的<br  />
</p>

<p>
指针赋值<br  />
int (* fun())()<br  />
表示 fun() 这个函数，返回一个指针，这个指针指向一个返回 int 类型的函数。<br  />
int (* foo())[]<br  />
表示 foo() 这个函数，返回一个指针，这个指针指向 int 类型的数组<br  />
int (*foo[])()<br  />
foo[] 这个数组里面都是指针，这些指针指向一个返回 int 类型的函数<br  />
</p>

<p>
char * const (next )()<br  />
next指针，指向一个函数，这个函数返回一个只读的指针，这个指针指向 char 类型<br  />
</p>
<pre class="example">
char (c[10])(int **p)
</pre>
<p>
c是一个含有十个元素的数组，其中每个元素都是一个指针，这些指针分别指向一个形参是 int**p 的函数，这个函数返回一个指针，这个指针指向 char<br  />
</p>


<p>
C语言声明，解读优先级<br  />
1.看名字  next<br  />
2.看括号  *next    一个指向什么的指针<br  />
3.看后缀  ()    一个指向一个函数的指针，这个函数木有参数。<br  />
4.看前缀  *    这个函数返回一个指针。<br  />
5.看修饰符 char * const    这个返回指针的类型是char* const类型<br  />
</p>
<div class="org-src-container">

<pre class="src src-C">char * const *( *next) ();     定义一个指针next,next是一个指向没有参数的函数（即函数指针），他的返回值是一个char* const*类型的指针。
char * （ *c[10] ) (int ** p) ;   定义了一个指向数组的指针c,这个数组里面的元素是函数指针，每个元素的参数是(int **p),返回值是char*类型
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">char *const *</td>
<td class="left">(*next)</td>
<td class="left">( );</td>
</tr>

<tr>
<td class="left">return type</td>
<td class="left">function name</td>
<td class="left">parameter list</td>
</tr>
</tbody>
</table>

<p>
而 char *const *  类似于：<br  />
char * const    pA = "abcde";<br  />
char * const * pB = &amp;pA;<br  />
</p>

<p>
typedef 与 define 区别<br  />
1.#define int_tmp int     int_tmp i; 合法<br  />
2.typedef int int_tmp;    int_tmp;非法<br  />
</p>

<p>
在连续几个变量的声明中，用typedef定义的类型能够保证声明中所有的变量均为同一种类型，而用#define定义的类型则无法保证<br  />
#define int_tmp int*      int_tmp a , b ; &#x2014;&gt;b 则不是指针<br  />
typedef char* char_tmp;   char_tmp a, b; &#x2014;&gt;a,b都是指针<br  />
</p>

<p>
typedef 应用在：数组、结构、指针及函数的组合类型<br  />
可移植性，当代码移植不同平台时，要选择正确的类型如short,int,long，只要用typedef中进行修改即可<br  />
</p>

<p>
typedef 不应该怎么用？<br  />
千万千万不要将 typedef 这么用，这样子用意义不明确。<br  />
</p>
<div class="org-src-container">

<pre class="src src-C">typedef int *ptr, (*fun)(), arr[5]; 
/* ptr is the type “pointer to int” 
 * fun is the type “pointer to a function returning int” 
 * arr is the type “array of 5 ints” 
 */

//以及
unsigned const long typedef int volatile *kumquat;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 这不是Bug，而是语言特性</h2>
<div class="outline-text-2" id="text-2">
<p>
进步——是计算机软件工程和编程语言设计艺术逐步发展的重要动因。这也是为什么C++语言令人失望的原因：它对C语言中存在的一些最基本问题没有什么改进，而它对C语言最重要的扩展(类)却是建立在脆弱的C类型模型上。<br  />
</p>

<p>
按照C语言的理念，程序员应该知道自己在干什么，而且保证自己的所作所为是正确的。<br  />
</p>

<p>
多做之过：fall through作为switch的默认行为是个失误；相邻的字符串自动合并成一个字符串；太多的缺省可见性，全局可见，<br  />
一个大型函数一群“内部”函数不得不在该函数的外部进行定义。没有人会记得在它们之前加上static限定符，所以他们在缺省情况下是全局可见的。<br  />
</p>

<p>
误做之过：<br  />
C语言中符号重载：static 在函数内部，表示该变量的值在各个调用间一直保持延续性；在函数这一极，表示该函数只对文本文件可见。extern用于函数定义表示全局可见(属于冗余)，用于变量，表示它在其他地方定义。<br  />
运算符优先级存在的问题：.优先级高于*, *p.f表示*(p.f)；函数()高于*；==和!=高于位运算符(val &amp; mask != 0)表示val &amp; (mask != 0)；==和!=高于赋值符，c = getchar() != EOF表示c = (getchar() != EOF)；算数运算符高于移位运算符 msb&lt;&lt;4 + lsb表示msb&lt;&lt;(4+lsb)；逗号最低。<br  />
有些专家建议在C语言中记牢两个优先级就够了：乘除先于加减，在涉及其他的操作符时一律加括号。<br  />
</p>

<p>
结合性，在几个操作符具有相同优先级时决定先执行哪一个。<br  />
</p>

<p>
计算的次序之所以未定义，是想让编译器充分利用自身架构的特点，或者充分利用存储于寄存器的值。<br  />
</p>

<p>
如果对于堆栈的每次访问之前都要检查其大小和访问权限，对于软件来说代价太大了，根本不可行。<br  />
</p>

<p>
gets(char *s)，不检查缓冲区的空间，而fgets(char *s, int n, FILE *stream)可以对读入的字符数设置一个上限n。fgets对缓冲大小进行限制的方式，更为安全。<br  />
</p>

<p>
少错之过，标准参数的处理以及把lint程序错误的从编译器中分离出来。<br  />
</p>

<p>
Lint Early, Lint Often<br  />
Lint is your software conscience. It tells you when you are doing bad things. Always use lint. Listen to your conscience.<br  />
gcc as lint，使用-Wall：enable a bunch of warning。gcc &#x2013;help=warning查询。<br  />
linux上可以使用splint。<br  />
</p>

<p>
让充满Bug的代码快速通过编译实在是不划算。-&#x2014;我习惯于写过代码后用眼睛看一遍，确认无误后再编译调试，看来以后可以在中间加上一步用lint检查。<br  />
</p>

<p>
大型缓冲区如果闲置不用是非常浪费空间的。<br  />
</p>

<p>
如果程序员可以在同一代码块中同时进行malloc和free操作，内存管理是最轻松的。<br  />
</p>

<p>
深刻教训：即使可以保证你的编程语言100%可靠，你仍然可能成为算法中灾难的牺牲品。-&#x2014;确实如此，学好算法。<br  />
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 分析C语言的声明</h2>
<div class="outline-text-2" id="text-3">
<p>
声明器(declarator),  就是标识符以及与它组合与它组合在一起的任何指针，函数括号，数组下标等。<br  />
以下形式：        标识符<br  />
        或                标识符[下标]<br  />
        或                标识符(参数)<br  />
        或                (声明器)<br  />
-&#x2014;注意括号不能乱加，就两个地方可以加括号<br  />
</p>

<p>
声明格式：类型说明符 声明器[,声明器];<br  />
</p>

<p>
类型说明符: int char void等<br  />
存储类型: extern static register auto<br  />
类型限定符: const volatile<br  />
</p>

<p>
理解C语言声明的优先级规则<br  />
A        声明从它的名字开始读取，然后按照优先级顺序依次读取。<br  />
B        优先级从高到底依次是：<br  />
                B.1 声明中被括号括起来的那部分<br  />
                B.2 后缀操作符：<br  />
                        括()表示一个函数，<br  />
                        []表示这是一个数组。<br  />
                B.3 前缀操作符：<br  />
                        *表示指向&#x2026;的指针<br  />
C        如果const和(或)volatile关键字与类型说明符(如int,long等)相邻，它作用于类型说明符；其他情况下const和(或)volatile关键字作用于它左边紧邻的指针*号。<br  />
</p>

<p>
用优先级规则分析C语言声明：<br  />
</p>
<div class="org-src-container">

<pre class="src src-C">char * const *(*next)();
char *(* c[10])(int **p);
</pre>
</div>

<p>
如果需要频繁地对整个数组进行赋值操作，可以通过把它放入struct中。<br  />
</p>

<p>
在调用函数中，参数传递时首先尽可能地存放到寄存器中(追求速度)。<br  />
</p>

<p>
union也可以把同一个数据解释成两种不同的东西，不用强制类型转换。<br  />
</p>

<p>
typedef和宏文本替换之间存在一个关键性的区别：typedef看成是一种彻底的"封装"类型——在它声明后不能再往里面增加别的东西。首先，可以用其他类型说明符对宏类型名进行扩展，但对typedef所定义的类型名称不能这样做。 typedef int banana; unsigned banana i; /*错误！ 非法 */； 其次连续几个变量声明。<br  />
-&#x2014;由于typedef由编译器解释的，而宏是由预处理器解释的<br  />
</p>

<p>
typedef void (*ptr_to_func)(int); //这样来定义函数指针的别名。<br  />
</p>

<p>
不要为了方便起见对结构使用typedef，这样做唯一的好处是能使你不必书写struct关键字，但这个关键字可以向你提示一些信息。<br  />
应该始终在struct的定义中使用结构标签，即使它并非必须。这种做法可以使代码更为清晰。结构标签的名字可以取一个以"_tag"结尾的名字。<br  />
</p>

<p>
C语言中存在多种名字空间：<br  />
</p>
<p>
在同一个名字空间，任何名字必须具有唯一性。<br  />
-&#x2014;C中也有名字空间，没注意啊<br  />
</p>

<p>
cdecl程序<br  />
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 令人震惊的事实：数组和指针并不相同</h2>
<div class="outline-text-2" id="text-4">
<p>
extern对象声明告诉编译器对象的类型和名字，对象的内存分配则在别处进行。<br  />
</p>

<p>
X = Y;<br  />
在这个上下文环境里，符号X的含义是X所代表的地址。这被成为左值。<br  />
在这个上下文环境里，符号Y的含义是Y所代表的地址的内容。这被称为右值。<br  />
左值在编译时可知，左值表示存储结果的地方。<br  />
右值直到运行时才知。如无特别说明，Y的值是指右值。<br  />
</p>

<p>
数组名是个左值，但不是可修改的左值。<br  />
</p>

<p>
指针是间接寻址，数组名是直接寻址，这就是两者在访问数据时的区别。指针的值是运行时从内存取得的，数名的值是编译时已经确定的。<br  />
</p>

<p>
专业的C程序员必须熟练的掌握malloc()函数，并且学会用指针操纵匿名内存。<br  />
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 对链接的思考</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 编译器</h3>
<div class="outline-text-3" id="text-5-1">
<p>
编译器设计者的金科玉律：效率=一切<br  />
标准设立后轻易不作变动，即使是修改错误<br  />
</p>

<p>
SRV4系统中:<br  />
编译器组成:<br  />
1.预处理器<br  />
2.语法和语义检查器(前端)<br  />
3.代码生成器(后端)<br  />
4.优化器<br  />
5.汇编程序<br  />
6.连接-载入器<br  />
</p>

<p>
c预处理器：1.字符串替换 2.头文件包含 3.通用代码模板的扩展<br  />
预处理一定要使用强制类型转换！！！明确数据类型<br  />
</p>

<p>
每一个ANSI C编译器必须能够支持：<br  />
@在函数定义中形参数量的上限至少可以达到31个。<br  />
@在函数调用时实参数量的上限至少可以达到31个。<br  />
@在一个源代码行里至少可以有509个字符<br  />
@在表达式中至少可以支持32层嵌套的括号<br  />
@long int的最大值不得小于2147483647（不得低于32位）<br  />
</p>

<p>
编译器使用:<br  />
1.-#选项查看编译过程的各个独立阶段。<br  />
2.-V选项能提供版本信息<br  />
3.-W选项向各个阶段传递选项信息。W后跟一个字符(表示那f个阶段)，一个逗号，然后就是具体的选项。<br  />
  例：cc -W1, -m main.c &gt; main.linker.map<br  />
4.-M选项传递给链接载入器，要求它产生连接器映象<br  />
</p>

<p>
编译器是怎么赋值的？<br  />
被分配在等号左边的符号叫做l-value，被分配在右边的符号叫做r-value<br  />
编译器分配地址给每个左边的符号，分配数值给右边的符号，<br  />
左边符号的地址在编译时就已经知道了，右边符号的数值要等到运行时才知道<br  />
如果右边符号的数值在编译时期就要知道，那么编译器会通过左边符号的地址来进行寻址，找到具体的数值之后，会将他放到寄存器里面<br  />
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 动态与静态链接</h3>
<div class="outline-text-3" id="text-5-2">
<p>
动态链接：执行文件只是包含了文件名，让载入器在运行时能够寻找程序所在的函数库<br  />
静态链接：函数的一份拷贝是可执行文件的物理组成部分<br  />
</p>

<p>
动态链接优点：<br  />
1.动态链接可执行文件比功能相同的静态链接可执行文件体积小<br  />
2.所有动态链接到某个特定函数库的可执行文件在运行时共享该函数库在内存中的一个单独拷贝。<br  />
3.动态链接使函数库的版本升级更为容易。<br  />
注意：所以的应用程序都使用动态链接<br  />
</p>

<p>
ABI(Application binary interface) 是我们使用动态链接的目的<br  />
ABI 保证了一些库是肯定会出现在编译环境上的，如libc(C runtimes), libsys(other system runtimes), libX(X windowing), libnsl(networking services)<br  />
其他的库可以静态链接，也可以动态链接<br  />
ABI优点：使软件不必因为新版本函数库或操作系统的发布而重新连接且能提高系统的总体性能<br  />
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> 函数库链接的秘密</h3>
<div class="outline-text-3" id="text-5-3">
<p>
1.动态库文件的扩展名是“.so”,静态库文件名是“.a”<br  />
2.传给C编译器的命令行参数里并没有提到函数的完整路径名(使用缩写，如libthread.so可用-lthread)。他甚至没有提到在函数库目录中该文件的完整名字。<br  />
3.编译器期望在确定的目录找到库。<br  />
4.观察头文件，确认所使用的函数库。<br  />
  a.头文件的名字通常并不与它所对应的函数库名相似。<br  />
  b.函数库包含许多函数的定义，但这些函数的原型声明却散布于多个头文件中。<br  />
5.与提取动态库中的符号相比，静态库中的符号提取方法限制更严。<br  />
注意：始终将-1函数库选项放在编译命令行的最右边<br  />
</p>

<p>
静态库和动态库怎么创建？<br  />
任何人都可以创建静态库。<br  />
将代码进行编译(不要编译main函数)，然后使用正确的文件编译出.o文件，名字前缀为ar的是静态库，为ld的是动态库<br  />
</p>

<p>
如何生成链接动态库的文件？<br  />
动态库都靠一个链接工具，名为ld命令。<br  />
一般动态库文件的后缀都是.so意思是share object<br  />
</p>

<p>
gcc创建动态链接库和使用<br  />
创建：gcc tomato.c -fPIC -shared -o libfruit.so<br  />
使用：gcc test.c -Wl,&#x2013;rpath,. -L. -lfruit<br  />
这样只要a.out和libfruit.so放在同一个目录就可以了<br  />
与位置无关的代码(position-independent code)，对于共享库显得格外有用，因为每个使用共享库的进程一般都会把它映射到不同的虚拟地址(尽管共享同一份物理拷贝)，只要修改一下偏移量表就可以了。<br  />
</p>

<p>
grep很有用啊！<br  />
</p>

<p>
始终将-l函数库选项放在编译命令行的最右边。<br  />
</p>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> 警惕Interpositoning</h3>
<div class="outline-text-3" id="text-5-4">
<p>
警惕Interpositoning。缺省全局作用域。<br  />
定义：通过编写与库函数同名的函数来代替库函数的行为。<br  />
C保留字不应该出现在自己程序的声明中。(P104-106表5-2)<br  />
准则：不要让程序中的任何符号成为全局的，除非有意把他们作为程序的接口之一。<br  />
</p>

<p>
ldd程序print shared library dependencies。<br  />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 运动的诗章：运行时数据结构</h2>
<div class="outline-text-2" id="text-6">
<p>
编程语言理论的经典对立之一就是代码和数据的区别。<br  />
代码和数据的区别也可以是编译时和运行时的分界线。编译器的绝大部分工作都跟翻译代码有关；必要的数据存储管理的绝大部分都在运行时进行。<br  />
</p>

<p>
linux可执行文件用文件第一个字节来标注，7F开头，紧跟后面的是"ELF"，代表Executable and Linking Format.<br  />
可执行文件由文本段、数据段和bss段组成，运行size a.out可查看各段大小。<br  />
bss段保存没有值的变量，事实上只是，给出了运行时所需要的bss段大小。<br  />
</p>

<p>
运行时数据结构有好几种：堆栈，过程活动记录，数据，堆等。<br  />
</p>

<p>
堆栈有3个用处：<br  />
堆栈为函数内部声明的局部变量提供存储空间。<br  />
进行函数调用时，堆栈存储与此有关的一些维护信息。<br  />
堆栈也可以被看作暂时存储区。比如计算表达式，存储中间结果。<br  />
alloca()函数分配的内存位于堆栈中，函数结束后自动销毁。<br  />
</p>

<p>
发现数据段和文本段的位置，以及位于数据段中的堆，方法是声明位于这些段的变量，并打印它们的地址。<br  />
</p>

<p>
过程活动记录：局部变量，参数，指向先前结构的指针，返回地址。<br  />
Fedora上测了下，一个只有一个int参数的函数调用，要用32个字节，参数4个，返回地址4，esp和ebp其他不知道。fame.h中是汇编，没太看懂。<br  />
</p>

<p>
编译器的设计者会尽可能地把过程活动记录的内容放到寄存器中，这样可以提高速度。<br  />
</p>

<p>
static变量保存在数据段，而不是堆栈中。<br  />
auto关键字几乎没什么用处，因为它只能用于函数内部，但是在函数内部声明的数据缺省就是这种分配。<br  />
</p>

<p>
setjmp和longjmp，在C++中变异为更普通的异常处理机制“catch”和“throw”。<br  />
</p>

<p>
对于如何在进程中支持不同的控制线程，只要简单地为每个控制线程分配不同的堆栈即可。<br  />
</p>

<p>
有用的C语言工具：<br  />
</p>

<p>
indent 代码缩进工具<br  />
默认GNU风格,使用-kr选项按K&amp;R风格。还有各种各样选项，可以定制。<br  />
语法: indent [选项] [源文件列表]<br  />
        indent [选项] [源文件] [-o 输出文件]<br  />
</p>

<p>
ldd 用来查看程式运行所需的共享库,常用来解决程式因缺少某个库文件而不能运行的一些问题。<br  />
</p>

<p>
nm 打印目标文件的符号表。<br  />
</p>

<p>
strace 工具trace system calls and signals<br  />
用法：strace [选项] command<br  />
</p>

<p>
gdb&#x2014;哈哈，常用<br  />
</p>

<p>
time显示程序所使用的实际时间和CPU时间<br  />
</p>

<p>
gprof列出程序的运行时分析图。<br  />
</p>

<p>
标准的代码优化技巧包括：消除循环，函数代码就地扩展，公共子表达式消除，改进寄存器分配，省略运行时对数组边界的检查，循环不变量代码移动，操作符长度削减(把指数操作转变为乘法操作，把乘法操作转变为移位操作或加法操作)等。<br  />
</p>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 对内存的思考</h2>
<div class="outline-text-2" id="text-7">
<p>
存储介质访问速度<br  />
快:CPU Registers,Cache Memory,Main Memory,Disk<br  />
</p>

<p>
堆的实现原理<br  />
堆的结尾用一个叫做break的指针指向着，当heap manager觉得需要更多内存时，就将这个指针向后移动，通过使用brk()和sbrk()，这两个指令你是无法通过显示指定的<br  />
但是如果你使用malloc分配了足够的内存，brk()会自动为你调用的<br  />
</p>

<p>
使用malloc()注意事项？内存泄露是怎么回事？<br  />
C 没有垃圾回收，所以你必须很小心的使用malloc()和free()<br  />
因为malloc()是分配heap内存，如果你没有及时清除，有可能会造成内存泄露。<br  />
malloc所分配的内存通常会圆乘为下一个大于申请数的2的整数次方。<br  />
</p>

<p>
如何预防内存泄露？<br  />
一个简单的预防内存泄露的方法，就是使用alloca()，alloca()会从stack里分配内存，而stack里的内存，都是用完就回收的。<br  />
但是在stack里面的东西，就最好不要放长期需要用到的变量，而且你不能在不支持stack的硬件上实现这个函数。<br  />
</p>

<p>
内存泄漏(leak)检查工具：<br  />
mtrace<br  />
valgrind<br  />
</p>

<p>
如何查看内存泄露(leak)？<br  />
其实就是观察内存的变化，有两种方法：<br  />
1.观察swap空间的大小<br  />
/usr/sbin/swap -s total<br  />
通过隔一段时间就输入一次上面的命令，来观察 swap 空间是否变小，来判断是否内存泄露了。<br  />
2.使用netstat或者vmstat这些监控工具来查看<br  />
如果你看到被使用的内存在不停的增加，那么就占用内存增长的最多的那个进程，就很有可能是内存泄露的来源<br  />
</p>

<p>
内存<br  />
1.每一个byte都有他自己的virtual address虚拟地址<br  />
2.bytes 只能在内存里面被引用<br  />
3.只有 VM manager 才知道一个 byte 是在内存里面，还是在硬盘里面？<br  />
4.唯一的引用你的byte的方法，是给他一个虚拟地址。<br  />
然而你的byte必须要存在内存里面才能被引用，如果你的程序要使用到的byte不存在内存里面，那么VM manager会去硬盘里面寻找，<br  />
找到的话，他会将硬盘里包含这个byte的page给引进memory里面，如果他发现，memory已经没有空间给他了，那么他会在memory里面找最老最没用的那个page，并且将这个page给抛出去，然后将那个page给引进来这个位置<br  />
而你根本就不知道这个过程所发生的事情<br  />
5.你不能够引用别人的virtual address，因为VM manager知道这个byte是属于那个程序的，就算这两个程序的某一个byte使用了相同的virtual address，你也没法引用别人程序的virtual address<br  />
</p>

<p>
总线错误，几乎都是由于未对齐的读或写引起的。-&#x2014;目前linux好像不出现错误<br  />
</p>

<p>
segment是什么概念？在x86和UNIX下有什么区别？<br  />
Unix，segment代表了一堆相关联的section联结在一起的东西<br  />
x86，内存模型不是全部一个整体的，而是被分成很多个segment，每一个segment大小是64Kbyte<br  />
</p>

<p>
如何查看 segment 的大小？<br  />
直接对某个文件运行size就行了，如size a.out<br  />
</p>

<p>
段错误是由于MMU(内存管理单元，负责支持虚拟内存的硬件)的异常所致，而该异常通常是由于解除引用(查看指针所指地址的内容)一个未初始化或非法值的指针引起的。<br  />
Keep it Simple, Stupid !<br  />
条件操作符简洁，允许我们高高兴兴的在一行内写下代码，而无需不必要的代码膨胀。<br  />
</p>

<p>
最可能导致段错误的常见编程错误是：<br  />
1.坏指针的错误。free(p);后值空 p = NULL;<br  />
2.改写错误。如数组越界。<br  />
3.指针释放引起的错误。<br  />
</p>

<p>
magic numbers 是什么？<br  />
可执行文件在 Unix 里面也是有标签那样的东西的，我们称这些东西为 magic numbers<br  />
程序可以通过 magic numbers 来推断出某个比特的集结体是什么东西，<br  />
如，可以通过下面的 magic number 来推断出他代表的是 superblock<br  />
#define FS_MAGIC 0x011954<br  />
</p>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 为什么程序员无法分清万圣节和圣诞节</h2>
<div class="outline-text-2" id="text-8">
<p>
很无厘头的开始。<br  />
</p>

<p>
类型提升：在任何表达式中，并不局限于涉及操作符和混合类型的操作数的表达式。<br  />
char, 位段, enum, unsigned char, short, unsigned char -&gt; int<br  />
float -&gt; double<br  />
任何数组 -&gt; 相应类型的指针。-&#x2014;注意<br  />
</p>

<p>
函数的参数也是表达式，所以也会发生类型提升。不用函数原型，会先提升再自动剪裁。<br  />
如果使用了函数原型，缺省参数提升就不会发生，与实际类型相符合。-&#x2014;但数组到指针的提升仍会发生<br  />
</p>

<p>
8.6 不需要按回车键就能得到一个字符，单字符I/O-&#x2014;用于游戏编程，这个我就不看了<br  />
</p>

<p>
有限自动机(FSM)可以用作程序的控制结构。<br  />
它的基本思路是用一张表保存所有可能的状态，并列出进入每个状态时可能执行的所有动作，其中最后一个动作就是计算(通常在当前状态和下一次输入字符的基础上，另外再经过一次表查询)下一个应该进入的状态。你从一个“初始状态”开始。在这一过程中，翻译表可能告诉你进入了一个错误的状态，表示一个预期之外的或错误的输入。你不停地在各种状态间转换，直到到达结束状态。<br  />
在C语言中，有好几种方法可以用来表达FSM，但他们绝大多数都是基于函数指针数组。一个函数指针数组可以像下面这样声明：<br  />
void (*state)[MAX_STATES]();<br  />
</p>

<p>
debugging hooks<br  />
调试器调试时可以调用函数，比如gdb用call [函数名](参数)，对于复杂的数据结构可以编写一个函数，用于遍历数据结构并打印出来。-&#x2014;时过境迁，现在强大的GUI调试器，这个已不怎么有用了。<br  />
</p>

<p>
8.8&#x2013;可调式性编码<br  />
可调式性编码意味着把系统分成几个部分，先让程序总体结构运行。只有基本的程序能够运行之后你才能为那些复杂的细节完善、性能调优和算法优化进行编码。<br  />
有时候，花点时间把编程问题分解成几个部分往往是解决它的最快办法。-&#x2014;确实得花时间，动脑筋来分解。<br  />
</p>

<p>
作者描写其同事，写散列表就是个例子啊。最初，使散列函数返回0，这样所有元素都存储于第0个位置后面的链表中。-&#x2014;这使得程序很容易调试<br  />
</p>

<p>
复杂类型转换，先写一个对象的声明，然后删去标识符，最后放在左面，如int (*compar)(int *)。<br  />
</p>

<p>
不加类型说明符，声明变量默认是int；函数默认返回值是int, 一般放在eax(第一个寄存器)中。int几乎是C语言所有的默认方式。应该也是C最善于处理的数据类型。<br  />
</p>

<p>
qsort函数原型：void qsort(void <b>base, size_t count, size_t size, int (*compar)(const void * element1, const void *element2));<br  />
compar函数参数可以定义为(const void *)类型，这需要在compar函数内部cast为所处理类型； 也可以直接定义为所处理类型的指针，在调用qsort函数时需要将compar函数cast为(int (</b>)(const void *, const void *)，一开始我以为这样不正确(因为qsort函数内部还是会调用compar的，这样类型就不匹配了啊)，其实是正确的，因为这种类型检查是编译时做的(gcc 使用-c选项)，链接时不做类型检查，只要能找到那个函数名就行，运行时取参数更不管这些东西了，是用ebp+offset直接抓来的。<br  />
</p>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 再论数组</h2>
<div class="outline-text-2" id="text-9">
<p>
数组的声明就是数组，指针的声明就是指针，两者不能混淆。声明与定义必须对应。<br  />
</p>

<p>
对于编译器而言，一个数组就是一个地址，一个指针就是一个地址的地址。-&#x2014;左值<br  />
</p>

<p>
什么时候数组和指针是相同的？<br  />
C语言标准对此作了如下说明：<br  />
规则1. 表达式中的数组名(与声明不同)被编译器当作一个指向该数组第一个元素的指针。<br  />
规则2. 下标(subscript)总是与指针的偏移(an offset from a pointer相同<br  />
规则3. 在函数参数的声明中，数组名被编译器当作指向该数组的第一个元素的指针-&#x2014;这里数组是指一维数组<br  />
</p>

<p>
指针有类型限制，是因为编译器需要知道对指针进行解除引用时应该取几个字节，以及每个下标的步长。<br  />
</p>

<p>
sizeof(数组名)结果是数组所占字节数(真正的数组，不是函数形参)，由此可见是可以数组名包含了长度信息，并可以通过sizeof取得，所以C中检查数组是否越界访问是能够做到的，但是很容易用指针避开，就像用指针可以修改const一样。我觉得编译器可以打开一个选项，是否检查数组越界访问。<br  />
</p>

<p>
把作为形参的数组和指针等同起来是出于效率原因的考虑。在C语言中，所有非数组形式数据实参均以传值形式。如果要copy整个数组，无论在时间上还是内存空间上的开销都可能是非常大的。<br  />
</p>
<pre class="example">
int apricot[2][3][5]; // apricot 两个[3][5]的数组，2*3个[5]的数组，2*3*5个int
int (*p)[3][5] = apricot; // 步长 3 * 5
int (*r)[5] = apricot[0]; // 步长 5
int *t = apricot[0][0]; // 步长 1
int u = apricot[0][0][0];
</pre>
<p>
指向数组第一个元素的指针与数组名等同。<br  />
</p>

<p>
内存中数组的布局<br  />
C语言中，最右边的下标最先变化，这个约定被称为"行主序"。<br  />
</p>

<p>
只有字符串常量才可以初始化指针数组，因为可执行文件中字符串常量是作为数据存储。而161这样的字面常量只出现在代码中。<br  />
</p>

<p>
数组与指针可交换性的总结：<br  />
</p>
<ol class="org-ol">
<li>用a[i]这样的形式对数组进行访问总是被编译器”改写“或解释为像*(a+i)这样的指针访问。<br  />
</li>
<li>指针始终就是指针。它绝不可以改写成数组。只是可以使用下标形式访问指针。<br  />
</li>
<li>在特定上下文中，也就是指针作为函数的参数(也就只有这种情况&#x2013;注意)，一个数组的声明可以看作是一个指针。作为函数参数的数组始终会被编译器修改成为指向数组中第一个元素的指针。<br  />
</li>
</ol>


<p>
数组和指针之间的区别:<br  />
arrays:保存数据,数据是被直接访问的,内存空间隐式分配和解除<br  />
pointer:保存数据的地址,数据是被间接访问的,内存空间用 malloc() 分配和 free() 解除<br  />
</p>

<p>
指针和数组的规则总结<br  />
1.访问a[i]时，经常被编译器编译成一个指针，那个代码等同于*(a+i)<br  />
2.Pointer永远不会被重新翻译成数组，你可以定义一个指针，然后在这个指针后面使用[i]的方式，来给指针赋值，这样子做等同于使用数组<br  />
</p>

<p>
数组的真实形态<br  />
pea[i][j]<br  />
会被编译器翻译成<br  />
*(*(pea+i)+j)<br  />
</p>

<p>
数组在内存里面是怎么分布的？<br  />
<img src="file:///home/qy/work/org/images/array_memory.png" alt="array_memory.png" /><br  />
</p>

<p>
c 定义动态数组的方法<br  />
核心思想:使用malloc()，得到一个指向一些内存空间的指针，将这个指针当成数组来用<br  />
</p>
<div class="org-src-container">

<pre class="src src-C">#include &lt;stdlib.h&gt; 
#include &lt;stdio.h&gt; 

. . . 
 int size;
 char *dynamic; 
 char input[10]; 
 printf(“Please enter size of array: “); 
 size = atoi(fgets(input,7,stdin)); 
 dynamic = (char *) malloc(size);
 . . . 
 dynamic[0] = ‘a’; 
 dynamic[size-1] = ‘z’;
</pre>
</div>

<p>
file descriptor 和 file pointer 区别<br  />
file descriptor在Unix里面是用来描述文件信息的<br  />
file pointer是保存了一个文件的指针<br  />
</p>

<p>
数组之间不能直接赋值<br  />
有一样操作只能在指针里进行而无法在数组中进行，就是修改直接修改数组值<br  />
</p>
<div class="org-src-container">

<pre class="src src-C">int array[100], array2[100];  

void fun1(int *ptr)  
{  
    ptr[1] = 3;  
    *ptr = 3;  
    ptr = array2;  
}  


void fun1(int arr[])  
{  
    arr[1] = 3;  
    *arr = 3;  
    arr = array2;  
}  


int main(int argc, char* argv[])  
{  
    array[1] = 3;  
    *array = 3;  
    array = array2;// error，这里会报错。  

    return 0;  
}
</pre>
</div>
<p>
fun2里数组之所以能被直接赋值，是因为它作为参数传进来时已经被当作指针处理了<br  />
</p>

<p>
用指针数组代替二维数组<br  />
</p>
<div class="org-src-container">

<pre class="src src-C">char vegetables[][10] = {  
	"carrot",  
	"celery",  
	"corn",  
};

char *vegetables[] = {  
    "carrot",  
	"celery",  
	"corn",  
};
</pre>
</div>
<p>
两种写法作用是一样的，但是这样的用法只能用在字符串常量上，其它类型是不能这样的<br  />
</p>
<div class="org-src-container">

<pre class="src src-C">int *weights[] = {  
	{1,2,3,4,5},  
	{6, 7},  
	{8,9,10}  
    };
</pre>
</div>
<p>
如果非要这样做，可以先创建几个单独的数组，在用这些数组初始化原先的数组<br  />
</p>
<div class="org-src-container">

<pre class="src src-C">int row_1[] = {1,2,3,4,5};  
int row_2[] = {6, 7};  
int row_3[] = {8,9,10};  

int *weights[] = {  
	row_1,  
	row_2,  
	row_3  
    };
</pre>
</div>

<p>
数组和指针的地址<br  />
</p>
<div class="org-src-container">

<pre class="src src-C">char ga[] = "abcdef";  

void my_array_func(char ca[10])  
{  
    printf("addr of array param = %#x \n",  &amp;ca);  
    printf("addr of array param = %#x \n",  ca);  
    printf("addr of array param[0] = %#x \n",  &amp;(ca[0]));  
    printf("addr of array param[1] = %#x \n",  &amp;(ca[1]));  
}  

void my_pointer_func(char *pa)  
{  
    printf("addr of ptr param = %#x \n",  &amp;pa);  
    printf("addr of ptr param = %#x \n",  pa);  
    printf("addr of ptr param[0] = %#x \n",  &amp;(pa[0]));  
    printf("addr of ptr param[1] = %#x \n",  &amp;(pa[1]));  
}  

int main(int argc, char* argv[])  
{  
    printf("addr of ga = %#x \n",  &amp;ga);  
    printf("addr of ga = %#x \n",  ga);  
    printf("addr of ga param[0] = %#x \n",  &amp;(ga[0]));  
    printf("addr of ga param[1] = %#x \n",  &amp;(ga[1]));  
    printf("****************************** \n");  
    my_array_func(ga);  
    printf("****************************** \n");  
    my_pointer_func(ga);  

    return 0;  
}
</pre>
</div>
<p>
输出:<br  />
</p>
<pre class="example">
addr of ga = 0x425168  
addr of ga = 0x425168  
addr of ga param[0] = 0x425168  
addr of ga param[1] = 0x425169  
#******************************  
addr of array param = 0x12fef8  
addr of array param = 0x425168  
addr of array param[0] = 0x425168  
addr of array param[1] = 0x425169  
#******************************  
addr of ptr param = 0x12fef8  
addr of ptr param = 0x425168  
addr of ptr param[0] = 0x425168  
addr of ptr param[1] = 0x425169  
Press any key to continue
</pre>
<p>
第一段，&amp;ga当然是数组的地址，ga为什么也是同样的结果呢？这只是刚好C语言规定数组名就是数组地址，所以&amp;ga和ga结果相同。<br  />
第二段，&amp;ca和ca不相等，这是因为数组作为参数传递时就会变为指针，&amp;ca是取的指针的地址(也就是数组的地址所在的地址)。<br  />
第三段与第二段原理一样<br  />
</p>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 再论指针</h2>
<div class="outline-text-2" id="text-10">
<p>
数组和指针参数是如何被编译器修改的？<br  />
“数组名被改写成一个指针参数”规则并不是递归定义的。数组的数组会被改写成“数组的指针”，而不是“指针的指针”。<br  />
</p>
<pre class="example">
数组的数组 char c[8][10];	char (*c)[10];  数组的指针
指针数组   char *c[15];		char **c;	指针的指针
指针的指针 char **c;		char **c;	不改变----指针与指针不用修改
数组的指针 char (*c)[64];	char (*c)[64]; 	不改变----注意，指向一个长度为64的char数组的数组名的指针，访问数组中元素这样做：(*c)[0]。

int a[20];
int **p = &amp;a;  // 错误，指针的指针与数组的指针不兼容
int (*t)[20] = &amp;a; // 正确，t为由20个int的数组的指针。
----此处括号是必须的，因为[]的优先级比*高
</pre>

<p>
Iliffe向量，创建一个一维数组，数组中的元素是指向其他东西的指针。<br  />
例如main(int argc, char *argv[])，第二个参数会被改写成char **。(注意，只有把二维数组改为一个指向向量的指针数组的前提下才可以这么做！)<br  />
</p>

<p>
在C语言中，传递多维数组必须提供除最左面一维以外的所有维的长度。<br  />
可以放弃多维数组的形式，提供自己的下标方式，如char_array[row_size*i + j] = &#x2026;<br  />
</p>

<p>
模拟动态数组，当表满后，用realloc()对数组重新分配内存，并确保realloc操作成功。<br  />
重分配操作很可能把原先的整个内存块移到一个不同的位置，这样表格中元素的地址便不再有效。为了避免麻烦，应该使用下标而不是元素的地址。-&#x2014;这也是STL中引入迭代器的一个原因吧<br  />
“增加”和“删除”操作都必须通过函数来进行，这样才能维持表的完整性。<br  />
</p>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 你懂得C，所以C++不在话下</h2>
<div class="outline-text-2" id="text-11">
<p>
类内部定义的函数是inline函数<br  />
</p>

<p>
重载是编译时解析的。<br  />
多态——运行时绑定。late binding<br  />
</p>

<p>
new和delete操作符，用于取代malloc()和free()函数，能够自动完成sizeof的计算工作，并会自动调用合适的构造函数和析构函数。new能真正的创建一个对象，malloc()函数只是分配内存。<br  />
</p>

<p>
C++的设计受限于严格的兼容性、内部一致性和高效率。<br  />
</p>

<p>
复用是软件科学的一个崇高而又朦胧的目标。-&#x2014;很多时候不如另起炉灶从头开始<br  />
</p>

<p>
管理和市场状况是导致许多公司破产的原因，比单纯的技术失败更为常见。那些不时刻注意顾客需求的公司终究难以为继，最能掌握这项艺术的公司往往能获得成功。<br  />
</p>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> 附录 程序员工作面试的秘密</h2>
<div class="outline-text-2" id="text-12">
<p>
面试的关键在于正确理解问题！你需要仔细地听，如果不理解问题或者觉得它的定义不清，可以要求一个更好的解释。<br  />
提供一种寻找可靠答案的好方法。<br  />
</p>

<p>
链表环的检测。<br  />
</p>

<p>
mango[i++] += y; // i++仅执行一次<br  />
</p>

<p>
优秀的程序员将会休息的更好，精力更加充沛，而蹩脚的程序员则很可能困得脑袋常常和桌子打架。<br  />
人类的最高目标是奋斗、寻求、创造<br  />
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: dqy</p>
<p class="date">Created: 2018-03-18 Sun 21:22</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
